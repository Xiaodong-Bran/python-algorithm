# find the k-th max number of the list

# 最大子序列之和 O(n)
# 关键是根据当前求的和，找到新的起点
'''
例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。
因此输出为该子数组的和 18 。
我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为 0。第一步加上第一个数字 1， 此时和为 1。
接下来第二步加上数字 -2，和就变成了 -1。
第三步刷上数字3。我们注意到由于此前累计的和是 －1 ，小于 0，那如果用-1 加上 3 ，得到的和是 2 ， 比 3 本身还小。
也就是说从第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和。
因此我们不用考虑从第一个数字开始的子数组，之前累计的和也被抛弃。
我们从第三个数字重新开始累加，此时得到的和是 3。
接下来第四步加 10，得到和为 13 。
第五步加上 -4， 和为 9。我们发现由于 -4 是一个负数，因此累加 -4 之后得到的和比原来的和还要小。
因此我们要把之前得到的和 13 保存下来，它有可能是最大的子数组的和。
第六步加上数字 7，9 加 7 的结果是 16，此时和比之前最大的和 13 还要大，
把最大的子数组的和由 13 更新为 16。第七步加上 2，累加得到的和为 18，同时我们也要更新最大子数组的和。
第八步加上最后一个数字 -5，由于得到的和为 13 ，小于此前最大的和 18，因此最终最大的子数组的和为 18 ，对应的子数组是｛3, 10, -4, 7, 2｝。
'''

def Max_sub_list(l):
    n = len(l)
    print("n: %d", n)
    thisSum,maxSum = 0,0
    for i in range(0,n):
        thisSum += l[i]
        if thisSum > maxSum:
            maxSum = thisSum
        elif thisSum < 0:
            thisSum = 0
    return maxSum

print(Max_sub_list([-1,2,3]))
